<!DOCTYPE html>
<html lang="en">
<head>
<!-- 2020-12-06 So 14:38 -->
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Advent of Code 2020, Day 3</title>
<meta name="generator" content="Org mode">
<meta name="author" content="Keshab Paudel">
<link rel='stylesheet' href='../static/index.css' />
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2020 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="content">
<h1 class="title">Advent of Code 2020, Day 3</h1>
<p>
Day three challenge is a bit tricky. I can see the next one being more
difficult, which is part of the fun.
</p>

<p>
I looked at the challenge and immediately found myself reaching for
Python shell. I'm not very familiar with the Clojure std lib for the
repl to be useful as a means to write PoC.
</p>

<p>
Since I'm trying to learn Clojure, the obvious choice would have been
to try to solve this on the Clojure repl. But I couldn't help it.
</p>

<p>
This also makes me wonder; is there a good quality "Clojure for Python
Programmers" crash course type guide? Something to help me map the
mappable concepts from Python to Clojure std lib.
</p>

<div id="outline-container-org1273a2a" class="outline-2">
<h2 id="org1273a2a">Python solution</h2>
<div class="outline-text-2" id="text-org1273a2a">
<p>
Here's what I came up with on the <code>ipython</code> shell.
</p>

<div class="org-src-container">
<pre class="src src-python">In [1]: forest = """
   ...: ..##.........##.........##.........##.........##.........##.......
   ...: #...#...#..#...#...#..#...#...#..#...#...#..#...#...#..#...#...#..
   ...: .#....#..#..#....#..#..#....#..#..#....#..#..#....#..#..#....#..#.
   ...: ..#.#...#.#..#.#...#.#..#.#...#.#..#.#...#.#..#.#...#.#..#.#...#.#
   ...: .#...##..#..#...##..#..#...##..#..#...##..#..#...##..#..#...##..#.
   ...: ..#.##.......#.##.......#.##.......#.##.......#.##.......#.##.....
   ...: .#.#.#....#.#.#.#....#.#.#.#....#.#.#.#....#.#.#.#....#.#.#.#....#
   ...: .#........#.#........#.#........#.#........#.#........#.#........#
   ...: #.##...#...#.##...#...#.##...#...#.##...#...#.##...#...#.##...#...
   ...: #...##....##...##....##...##....##...##....##...##....##...##....#
   ...: .#..#...#.#.#..#...#.#.#..#...#.#.#..#...#.#.#..#...#.#.#..#...#.#
   ...: """.strip().split("\n")

In [2]: def count_trees(jungle, down, right):
   ...:     x, y = 0, 0
   ...:     tree_count = 0
   ...:     total_levels = len(jungle)
   ...:     x_len = len(jungle[0])
   ...:     while y &lt; total_levels:
   ...:         targetY = jungle[y]
   ...:         char = targetY[x]
   ...: 
   ...:         if char == "#":
   ...:             tree_count += 1
   ...: 
   ...:         y += down
   ...:         x += right
   ...:         if x &gt;= x_len:
   ...:             x = divmod(x, x_len)[1]
   ...:     return tree_count
   ...: 

In [3]: count_trees(forest, 1, 3)
Out[3]: 7
</pre>
</div>

<p>
It took several attempts to reach here. I also restarted <code>ipython</code>
shell to make <code>In [1]</code> appear so as to give the impression that I
solved it on my first try.
</p>

<p>
The same function can be used to solve the second part of the challenge. 
</p>

<div class="org-src-container">
<pre class="src src-python">In [4]: with open("resources/day3-input.txt") as fi:
   ...:     jungle = list(filter(bool, map(str.strip, fi.readlines())))
   ...: 

In [5]: import math

In [6]: math.prod([count_trees(jungle, down, right) for right, down in
		   [(1, 1), (3, 1), (5, 1), (7, 1), (1, 2)]])
Out[6]: 1744787392
</pre>
</div>

<p>
Unlike my previous solutions, this one didn't need significant
refactoring but it was a coincidence.
</p>

<p>
The problem with this solution is that a "literal translation" to
Clojure is going to look like a pile of vomit; if possible that is.
This function not written in a functional way.
</p>
</div>
</div>


<div id="outline-container-org1c18ff4" class="outline-2">
<h2 id="org1c18ff4">Clojure</h2>
<div class="outline-text-2" id="text-org1c18ff4">
<p>
It took me until the weekend to get back to it again. I'm picking it
up by implementing the day 3 solution in Clojure.
</p>

<p>
Here's the final product. 
</p>

<div class="org-src-container">
<pre class="src src-clojure">(ns advent-of-code.day3
  (:gen-class)
  (:use [clojure.string :only [split-lines]]))

(defn read-input [] (split-lines (slurp  "./resources/day3-input.txt")))

(defn traverse-x
  [line x]
  (if (&lt; x 0)
    nil
    (get line (mod x (count line)))))

(defn is-a-tree?
  [lines x y]
  (let [line (get lines y)
	point-chr (if (nil? line) nil (traverse-x line x))]
    (= point-chr \#)))

(defn count-trees [[right down]]
  (let [lines (read-input)
	total-lines (count lines)]
    (loop [x 0
	   y 0
	   treecount 0]

      (if (&gt; y total-lines)
	;; we've exhausted the tree line; return
	treecount

	;; traverse and see there's a tree exists
	(let [is-tree (is-a-tree? lines x y)
	      treecount (if is-tree (+ 1 treecount) treecount)
	      x (+ x right)
	      y (+ y down)]
	  (recur x y treecount))))))


(defn part1 []
  (count-trees [3 1]))

(defn part2 []
  (let [slopes [[1 1] [3 1] [5 1] [7 1] [1 2]]]
    (reduce * (map count-trees slopes))))
</pre>
</div>

<p>
I'm sure this can be improved a lot. I've never been comfortable with
my understanding of loops/iterations in lisps. I hope to fix that with
some practice in the coming days.
</p>

<p>
I also learned that I could group test assertions together in one
<code>deftest</code>. It makes perfect sense on hindsight but I'm a slow learner.
</p>

<div class="org-src-container">
<pre class="src src-clojure">(deftest test-solutions
  (testing "test solutions"
    (is (= (part1) 257))
    (is (= (part2) 1744787392))))
</pre>
</div>


<p>
I'm off to solving day 4. This time I'll try to skip solving in Python
and try to do it on Clojure altogether.
</p>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="date">Date: 2020-12-03 Do 22:27</p>
<p class="author">Author: Keshab Paudel</p>
<p class="date">Created: 2020-12-06 So 14:38</p>
<p class="creator"><a href="https://www.gnu.org/software/emacs/">Emacs</a> 27.1 (<a href="https://orgmode.org">Org</a> mode 9.3)</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
